# NFR Assessment: Epic 3 - Dashboard & Interactive Visualizations

**Date:** 2025-10-05
**Reviewer:** Quinn (QA Test Architect)
**Epic:** Epic 3: Dashboard & Interactive Visualizations
**Scope:** Security, Performance, Reliability, Maintainability

---

## Executive Summary

| NFR Area | Status | Quality Score Impact |
|----------|--------|---------------------|
| **Security** | PASS | 0 |
| **Performance** | CONCERNS | -10 |
| **Reliability** | CONCERNS | -10 |
| **Maintainability** | PASS | 0 |

**Overall Quality Score:** 80/100

**Risk Level:** üü® **MEDIUM** - Performance testing critical

---

## Security Assessment

**Status:** PASS

### Findings

‚úÖ **PASS Areas:**
- No user input in dashboard queries (read-only operations)
- Chart.js auto-sanitizes data (prevents XSS in chart labels)
- Dashboard data fetched via authenticated API endpoints (Phase 2 auth)
- No file uploads or external data sources
- URL-based state uses validated query params (Story 3.5 AC #4)

‚úîÔ∏è **Low Risk:**
- Dashboard is primarily data visualization (minimal attack surface)
- All data sourced from SQLite cache (no external APIs)
- Angular templates auto-escape by default

### Recommendations

**Nice-to-Have (Defer to Epic 4):**
- Add CSRF token validation for future state-modifying operations

---

## Performance Assessment

**Status:** CONCERNS

### Findings

‚ö†Ô∏è **CONCERNS:**

1. **NFR1 Testing Deferred to Story 3.6**
   - Risk: Dashboard load <2s for 5,000 txns not validated until end of epic
   - Mitigation: Story 3.6 explicitly tests NFR1
   - Impact: MEDIUM (Could require rework if failed)

2. **No Caching Strategy Defined for Widgets**
   - Risk: Story 3.1-3.4 don't specify widget-level caching
   - Example: Net worth, expense chart, income/expense all hit SQLite separately
   - Mitigation: Single `/api/dashboard` endpoint returning all widget data
   - Impact: HIGH (3-5x slower than necessary)

3. **Chart.js Rendering Performance Not Addressed**
   - Risk: Large datasets (5,000 points) could freeze UI during chart render
   - Mitigation: Data pagination for charts (max 500 points), lazy load widgets
   - Impact: MEDIUM (Violates NFR5: 60fps)

4. **FileSystemWatcher Could Trigger Excessive Refreshes**
   - Risk: External .hledger edit ‚Üí full cache rebuild ‚Üí dashboard re-render
   - Example: User adds 1 txn via CLI ‚Üí entire 5,000 txn cache invalidated
   - Mitigation: Incremental cache updates (diff-based)
   - Impact: HIGH (Could cause 5-10s freeze)

5. **No Query Optimization Strategy**
   - Risk: Story 3.2-3.3 don't mention SQL indexes for category aggregations
   - Mitigation: Add indexes on `category`, `date`, `amount` columns
   - Impact: MEDIUM (Could add 500ms-1s to queries)

### Recommendations

**Critical (Fix in Epic 3):**

1. **Implement Unified Dashboard Query** (Story 3.1):
   ```csharp
   public record GetDashboardQuery(DateRange Range);
   public record DashboardViewModel
   {
       public NetWorthData NetWorth { get; init; }
       public ExpenseBreakdown[] Expenses { get; init; }
       public IncomeExpenseData[] IncomeVsExpense { get; init; }
       public Transaction[] RecentTransactions { get; init; }
   }
   ```
   **Effort:** 3 hours
   **Benefit:** Single DB round-trip (3-5x faster)

2. **Add Database Indexes** (Story 3.6):
   ```sql
   CREATE INDEX idx_transactions_category ON transactions(category);
   CREATE INDEX idx_transactions_date ON transactions(date);
   CREATE INDEX idx_transactions_amount ON transactions(amount);
   ```
   **Effort:** 1 hour
   **Benefit:** 50-80% query time reduction

3. **Implement Incremental Cache Updates**:
   ```csharp
   public async Task OnFileSystemChanged(FileSystemEventArgs e)
   {
       var newHash = ComputeFileHash(e.FullPath);
       var cachedHash = await _metadata.GetCachedHash();

       if (newHash != cachedHash)
       {
           var diff = await _hledgerRunner.GetDiff(cachedHash, newHash);
           await _cache.ApplyIncrementalUpdate(diff); // Only update changed txns
           await _signalR.Clients.All.SendAsync("DashboardRefresh");
       }
   }
   ```
   **Effort:** 6 hours
   **Benefit:** <1s refresh vs 5-10s full rebuild

4. **Add Chart Data Pagination** (Story 3.2-3.3):
   ```typescript
   // Limit chart data to 500 points max
   const chartData = expenses.length > 500
       ? aggregateByWeek(expenses) // Aggregate daily ‚Üí weekly
       : expenses;
   ```
   **Effort:** 2 hours per chart (6 hours total)
   **Benefit:** Maintains 60fps (NFR5)

**Important (Add in Story 3.6):**

5. **Add Performance Monitoring**:
   ```csharp
   [Fact]
   public async Task Dashboard_5000Transactions_LoadsUnder2Seconds()
   {
       await SeedDatabase(5000);
       var stopwatch = Stopwatch.StartNew();
       var result = await _handler.Handle(new GetDashboardQuery());
       stopwatch.Stop();

       Assert.True(stopwatch.Elapsed < TimeSpan.FromSeconds(2));
       _testOutput.WriteLine($"Dashboard load: {stopwatch.ElapsedMilliseconds}ms");
   }
   ```
   **Effort:** 4 hours (Story 3.6 already allocated)

---

## Reliability Assessment

**Status:** CONCERNS

### Findings

‚úÖ **PASS Areas:**
- Read-only operations (no data mutation ‚Üí lower risk)
- Graceful degradation: Loading spinners handle slow queries (Story 3.1 AC #5)
- Empty state handling (Story 3.4 AC #6)

‚ö†Ô∏è **CONCERNS:**

1. **Cache Out-of-Sync Detection Missing**
   - Risk: SQLite cache drifts from .hledger file (external edits not detected)
   - Current: FileSystemWatcher detects changes (Epic 3 scope), but no hash validation
   - Mitigation: Add hash comparison on dashboard load
   - Impact: HIGH (Displays incorrect data)

2. **No Fallback for hledger Process Failure**
   - Risk: Dashboard fails completely if hledger binary not found
   - Mitigation: Display cached data with warning banner "Cache may be stale"
   - Impact: MEDIUM (UX degradation vs hard failure)

3. **FileSystemWatcher Race Conditions**
   - Risk: Multiple rapid file changes trigger overlapping cache rebuilds
   - Example: User runs `hledger add` 3 times ‚Üí 3 concurrent rebuilds
   - Mitigation: Debounce FileSystemWatcher events (500ms delay)
   - Impact: MEDIUM (Performance + potential cache corruption)

4. **No Health Check for Dashboard Queries**
   - Risk: Slow queries (>2s) not logged or alerted
   - Mitigation: Add performance logging (Serilog with threshold warnings)
   - Impact: LOW (Observability issue, not functional)

### Recommendations

**Critical (Fix in Epic 3):**

1. **Add Cache Hash Validation** (Story 3.1):
   ```csharp
   public async Task<DashboardViewModel> Handle(GetDashboardQuery query)
   {
       var cacheHash = await _metadata.GetCachedHash();
       var fileHash = ComputeFileHash(_hledgerPath);

       if (cacheHash != fileHash)
       {
           _logger.Warning("Cache out of sync. Rebuilding...");
           await RebuildCacheFromHledger();
       }

       return await FetchDashboardData(query);
   }
   ```
   **Effort:** 3 hours

2. **Add FileSystemWatcher Debouncing**:
   ```csharp
   private Timer _debounceTimer;

   private void OnFileChanged(object sender, FileSystemEventArgs e)
   {
       _debounceTimer?.Dispose();
       _debounceTimer = new Timer(500);
       _debounceTimer.Elapsed += async (s, args) =>
       {
           await HandleFileChange(e);
           _debounceTimer.Dispose();
       };
       _debounceTimer.Start();
   }
   ```
   **Effort:** 2 hours

**Important (Add in Epic 4):**

3. **Add Fallback for hledger Failures** (Story 3.1):
   ```csharp
   try
   {
       var netWorth = await _hledgerRunner.GetNetWorth();
   }
   catch (HledgerBinaryNotFoundException)
   {
       _logger.Error("hledger binary not found. Using cached data.");
       return new DashboardViewModel
       {
           NetWorth = await GetCachedNetWorth(),
           Warning = "Dashboard using cached data. hledger binary not found."
       };
   }
   ```
   **Effort:** 2 hours

4. **Add Performance Logging** (Story 3.6):
   ```csharp
   var stopwatch = Stopwatch.StartNew();
   var data = await FetchDashboardData(query);
   stopwatch.Stop();

   if (stopwatch.Elapsed > TimeSpan.FromSeconds(2))
       _logger.Warning("Dashboard load exceeded 2s: {Elapsed}ms", stopwatch.ElapsedMilliseconds);
   ```
   **Effort:** 1 hour

---

## Maintainability Assessment

**Status:** PASS

### Findings

‚úÖ **PASS Areas:**
- Clear story breakdown (6 stories, each focused on single widget/feature)
- Responsive layout design (Story 3.1 AC #6)
- Reusable Chart.js components (Story 3.2-3.3)
- Drill-down navigation follows consistent pattern (Story 3.5)
- Performance test integrated into epic (Story 3.6)

‚úîÔ∏è **Strengths:**
- VSA structure: Dashboard query handlers co-located with tests
- Integration tests validate real hledger queries (not mocked)
- Clear performance baseline documented (Story 3.6 AC #6)

### Recommendations

**Nice-to-Have:**
- Extract Chart.js wrapper into shared component library (reduce duplication)

---

## NFR Traceability Matrix

| NFR | Requirement | Epic 3 Coverage | Evidence | Status |
|-----|-------------|----------------|----------|--------|
| NFR1 | Dashboard <2s for 5,000 txns | ‚úÖ Testable | Story 3.6 AC #3 | **ADD INDEXES** |
| NFR3 | Search/filter <1s | ‚è∏Ô∏è Deferred | Epic 4 (search), Epic 7 (filter) | N/A |
| NFR4 | Cold start <3s | ‚úÖ Inherited | Epic 1 validated | PASS |
| NFR5 | 60fps interactions | ‚ö†Ô∏è At Risk | Large charts could freeze UI | **ADD PAGINATION** |
| NFR15 | FileSystemWatcher <1s refresh | ‚úÖ Implemented | Story 3.6 scope | **ADD DEBOUNCE** |

---

## Gate-Ready YAML Block

```yaml
nfr_validation:
  _assessed: [security, performance, reliability, maintainability]
  _epic: "Epic 3: Dashboard & Interactive Visualizations"
  _date: "2025-10-05"
  _risk_level: MEDIUM

  security:
    status: PASS
    notes: |
      - Low attack surface (read-only visualization)
      - Angular + Chart.js auto-sanitize data
      - URL-based state validated
      - No external data sources
      Recommendation: Add CSRF tokens in Epic 4 (state-modifying ops)

  performance:
    status: CONCERNS
    notes: |
      HIGH:
      - No unified dashboard query (3-5x slower) - Refactor to single endpoint
      - No SQL indexes defined - Add category, date, amount indexes
      - FileSystemWatcher could trigger full cache rebuild - Use incremental updates
      MEDIUM:
      - Chart.js rendering 5,000 points - Add pagination (max 500 points)
      - No query optimization - Add indexes before Story 3.6 test
      Action: Add indexes, unified query, chart pagination

  reliability:
    status: CONCERNS
    notes: |
      HIGH:
      - No cache hash validation - Dashboard could show stale data
      MEDIUM:
      - FileSystemWatcher race conditions - Debounce events (500ms)
      - No fallback for hledger failures - Display cached data with warning
      LOW:
      - No performance logging - Add threshold warnings (>2s)
      Action: Add hash validation, debouncing in Story 3.1

  maintainability:
    status: PASS
    notes: |
      - Clear story breakdown (1 widget per story)
      - Responsive layout design
      - Reusable Chart.js components
      - Performance test integrated (Story 3.6)
      - VSA structure enforced
      Recommendation: Extract Chart.js wrappers to shared library
```

---

## Critical Issues (Must-Fix Before Epic 4)

### 1. Missing Database Indexes
**Severity:** HIGH
**Issue:** Category/date aggregations will be slow without indexes
**Fix:** Add indexes before Story 3.6 performance test
**Effort:** 1 hour

### 2. No Unified Dashboard Query
**Severity:** HIGH
**Issue:** Separate API calls for each widget (3-5x slower)
**Fix:** Refactor to single `/api/dashboard` endpoint
**Effort:** 3 hours

### 3. Cache Out-of-Sync Detection Missing
**Severity:** HIGH
**Issue:** Dashboard could show stale data if cache drifts
**Fix:** Add hash validation on dashboard load
**Effort:** 3 hours

### 4. FileSystemWatcher Race Conditions
**Severity:** MEDIUM
**Issue:** Multiple rapid changes trigger overlapping rebuilds
**Fix:** Debounce events (500ms delay)
**Effort:** 2 hours

---

## Quick Wins (Low Effort, High Impact)

### 1. Add Database Indexes
**Effort:** 1 hour
**Impact:** 50-80% query time reduction
**Code:** (see Performance section above)

### 2. Add Performance Logging
**Effort:** 1 hour
**Impact:** Early detection of slow queries
**Code:** (see Reliability section above)

### 3. Add Chart Data Pagination
**Effort:** 2 hours per chart
**Impact:** Maintains 60fps for large datasets
**Code:** (see Performance section above)

---

**Assessment Complete**
**Next Step:** Address 4 critical issues before Epic 4 development

**Estimated Fix Effort:** 9 hours
**Recommended Timeline:** No change (fixes fit within Epic 3 Week 4 scope)
